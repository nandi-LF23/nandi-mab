<?php

namespace App\ParserGenerators;

use Illuminate\Support\Facades\Log;

/*
    source:   null,
    type:     null,
    target:   null,
    config:   null,
    logic:    null,
    children: []
*/

/*
    CASE: null   -> array (Top Level Array) (INITIALIZE) (RECURSE)
    CASE: array  -> array (Nested Array) (LOOP MORE) (RECURSE)
    CASE: object -> array (Array Object Member) (TOTAL+ASSIGN)

    CASE: null   -> object (Top Level Object) (INITIALIZE) (RECURSE)
    CASE: array  -> object (Object in Array) (RECURSE)
    CASE: object -> object (Nested Object) (RECURSE)

    CASE: null   -> primitive (Top Level Primitive) (NOT ALLOWED)
    CASE: array  -> primitive (Primitive Array Member)
    CASE: object -> primitive (Primitive Object Member) (ASSIGN)
*/

class JSONParserGenerator {

    protected $json_spec;

    protected $node_types;
    protected $mode;

    public function __construct($json_spec)
    {
        $this->json_spec = $json_spec;
    }

    public function generate()
    {
        $spec_array = json_decode($this->json_spec, true);

        if(empty($spec_array) || !is_array($spec_array)){ 
            throw new \Exception("Invalid/corrupt JSON");
        }

        $out = ''; // generated code

        // JSON generated by frontend is always an array
        $spec = $spec_array[0];

        $data = $spec['data'];
        $meta = $spec['meta'];

        // Setup Global Meta Properties to aid in parsing
        $this->node_types = $meta['supported_types']; // Array of Supported Node Types
        $this->mode       = $meta['mode']; // Single/Multiple

        // Prop Validation

        // Confirm node_types are correct
        foreach($this->node_types as $type){
            if(!in_array($type, ['Nutrients', 'Soil Moisture', 'Wells', 'Water Meter'])){
                throw new \Exception("emitStartCode: Invalid Node Type");
            }
        }

        // Finally, let the parsing begin!

        try {

            $out  = $this->emitStartCode($data);
            $out .= $this->parseSpec($data);
            $out .= $this->emitFinishCode();

        } catch (\Exception $e){

            Log::debug($e->getMessage());
            $out = false;

        }

        return $out;
    }

    protected function emitStartCode($node)
    {
        $out = "";

        if(!$this->isValidNode($node)){
            throw new \Exception("Parse error: Invalid Node @ depth = $d");
        }

        // Add Namespaces use statement

        if(in_array('Nutrients', $this->node_types)){
            $out .= "\n\nuse App\\nutrients_data;\n\n";
        }
        if(in_array('Soil Moisture', $this->node_types)){
            $out .= "\n\nuse App\\node_data;\n\n";
        }
        if(in_array('Wells', $this->node_types) || in_array('Water Meter', $this->node_types)){
            $out .= "\n\nuse App\\node_data_meters;\n\n";
        } 

        // $json_data to be globally passed into eval'd code
        $out .= "// BEGIN SETUP\n";
        $out .= "\$data = json_decode(\$json_data, true);\n"; 
        $out .= "if(empty(\$data)){ return; }\n";
        // use an array for both single and multiple readings
        $out .= "\$items = [];\n";
        $out .= "// END SETUP\n\n";
        $out .= "// BEGIN PARSE\n";

        return $out;
    }

    public function parseSpec($node, $parent = null, $grandp = null, $d = 1)
    {
        if(!$this->isValidNode($node)){
            throw new \Exception("Parse error: Invalid Node @ depth = $d");
        }

        $t = $d > 1 ? $this->indent($d, 2, " ") : "";
        $record = $d > 1 ? ("\$row".($d-1)) : "\$data";
        $out = '';

        if($parent == null){
            if($node['type'] == 'array'){

                // [ TOP LEVEL ARRAY ]

                // Begin Loop
                $out .= "{$t}\$rows$d = {$record};\n";
                $out .= "{$t}foreach(\$rows$d as \$key$d => \$row$d){\n";

                $t2 = $this->indent($d+1, 2, " ");

                // Create Item
                if(in_array('Nutrients', $this->node_types)){
                    $out .= "{$t2}\$item = new nutrients_data;\n";
                } 
                if(in_array('Soil Moisture', $this->node_types)){
                    $out .= "{$t2}\$item = new node_data;\n";
                } 
                if(in_array('Wells', $this->node_types) || in_array('Water Meter', $this->node_types)){
                    $out .= "{$t2}\$item = new node_data_meters;\n";
                }

                // Recurse
                foreach($node['children'] as $child){
                    //$out .= "{$t2}// RECURSE $d\n";
                    $out .= $this->parseSpec($child, $node, $parent, $d+1);
                }

                // Store Item
                $out .= "{$t2}\$items[] = \$item;\n";

                // End Loop
                $out .= "{$t}}\n"; // end for

            } else if($node['type'] == 'object'){

                // [ TOP LEVEL OBJECT ]

                // Create Item (If Plurality is 'single')
                if($this->plurality == 'single'){

                    if(in_array('Nutrients', $this->node_types)){
                        $out .= "{$t}\$item = new nutrients_data;\n\n";
                    } 
                    if(in_array('Soil Moisture', $this->node_types)){
                        $out .= "{$t}\$item = new node_data;\n\n";
                    } 
                    if(in_array('Wells', $this->node_types) || in_array('Water Meter', $this->node_types)){
                        $out .= "{$t}\$item = new node_data_meters;\n\n";
                    }
                }

                // Recurse (-> Object Members)
                foreach($node['children'] as $child){
                    //$out .= "{$t}// RECURSE $d\n";
                    $out .= $this->parseSpec($child, $node, $parent, $d);
                }

                // Store Item (If Plurality is 'single')
                if($this->plurality == 'single'){
                    $out .= "{$t}\$items[] = \$item;\n";
                }

            } else if(in_array($node['type'], ['number','text','bool'])) {

                // [ TOP LEVEL PRIMITIVE ]

                throw new \Exception('top level primitive not allowed');
            }
        } else {
            if($parent['type'] == 'array'){
                if($node['type'] == 'array'){

                    // [ ARRAY -> ARRAY ]

                    // Begin Loop
                    $out .= "{$t}\$rows$d = {$record};\n";
                    $out .= "{$t}foreach(\$rows$d as \$key$d => \$row$d){\n";

                    // Recurse
                    foreach($node['children'] as $child){
                        //$out .= "{$t}// RECURSE $d\n";
                        $out .= $this->parseSpec($child, $node, $parent, $d+1);
                    }

                    // End Loop
                    $out .= "{$t}}\n"; // end for

                } else if($node['type'] == 'object'){

                    // [ ARRAY -> OBJECT ]

                    // Recurse
                    foreach($node['children'] as $child){
                        //$out .= "{$t}// RECURSE $d\n";
                        $out .= $this->parseSpec($child, $node, $parent, $d);
                    }

                } else {

                    // [ ARRAY -> PRIMITIVE ]

                    // Ensure Target is Populated
                    if(empty($node['target'])){
                        throw new \Exception('Array Members must have Target field Populated');
                    }

                    // CASE: Array of Numbers
                    if($node['type'] == 'number'){
                        if($node['target'] == 'SM Reading'){
                            $out .= "{$t}// 'Array of SM Reading' Member TODO\n";
                        } else if($node['target'] == 'Temp Reading'){
                            $out .= "{$t}// 'Array of Temp Reading' Member TODO\n";
                        }
                    // CASE: Array of Text
                    } else if($node['type'] == 'text'){
                        $out .= "{$t}// Text Array Member TODO\n";
                    // CASE: Array of Bool
                    } else if($node['type'] == 'bool'){
                        // Highly improbable
                        $out .= "{$t}// Bool Array Member TODO\n";
                    }

                }
            } else if($parent['type'] == 'object'){
                if($node['type'] == 'array'){

                    // [ OBJECT -> ARRAY ]

                    if(empty($node['source'])){
                        throw new \Exception("object array member requires non-empty 'source' field");
                    }

                    // CASE 1: Array stores objects (RECURSE)
                    // CASE 2: Array stores variable objects (LOGIC+RECURSE)
                    // CASE 3: Array stores primitive values (REDUCE)

                    // Begin Loop
                    $out .= "{$t}\$rows$d = {$record}['{$node['source']}'];\n";
                    $out .= "{$t}foreach(\$rows$d as \$row$d){\n";

                    // Accumulator Array ? Output Item Create Code
                    if(!empty($node['config']['accumulator']) && $node['config']['accumulator'] == 'true'){

                        $t2 = $this->indent($d+1, 2, " ");

                        if(in_array('Nutrients', $this->node_types)){
                            $out .= "{$t2}\$item = new nutrients_data;\n\n";
                        } 
                        if(in_array('Soil Moisture', $this->node_types)){
                            $out .= "{$t2}\$item = new node_data;\n\n";
                        } 
                        if(in_array('Wells', $this->node_types) || in_array('Water Meter', $this->node_types)){
                            $out .= "{$t2}\$item = new node_data_meters;\n\n";
                        }

                    }

                    // Recurse
                    foreach($node['children'] as $child){
                        //$out .= "{$t}// RECURSE $d\n";
                        $out .= $this->parseSpec($child, $node, $parent, $d+1);
                    }

                    // Accumulator Array ? Output Item Store Code
                    if(!empty($node['config']['accumulator']) && $node['config']['accumulator'] == 'true'){
                        // Store Item
                        $out .= "{$t2}\$items[] = \$item;\n";
                    }

                    // End Loop
                    $out .= "{$t}}\n"; // end for

                } else if($node['type'] == 'object'){

                    // [ OBJECT -> OBJECT ]

                } else {

                    // [ OBJECT -> PRIMITIVE ]

                    // Ensure Source is Populated
                    if(empty($node['source'])){
                        throw new \Exception("object primitive member requires non-empty 'source' field");
                    }

                    // Ensure Target is Populated
                    if(empty($node['target'])){
                        throw new \Exception("object primitive member requires non-empty 'source' field");
                    }

                    // CASE: Numeric Object Member (SM Reading / Temp Reading)
                    if($node['type'] == 'number'){

                        // TODO
                        $out .= "{$t}\$item->xxx = {$record}['{$node['source']}'];\n";


                        // TODO: Rewrite (to work with either index or config)
                        // if($node['target'] == 'SM Reading' && ctype_digit($node['meta'])){
                        //     $out .= "{$t}\$item->sm{$node['meta']} = {$record}['{$node['source']}']\n";
                        // } else if($node['target'] == 'Temp Reading' && ctype_digit($node['meta'])){
                        //     $out .= "{$t}\$item->t{$node['meta']} = {$record}['{$node['source']}']\n";
                        // }

                    } else if($node['type'] == 'text'){

                        // TODO
                        $out .= "{$t}\$item->xxx = {$record}['{$node['source']}'];\n";

                    } else if($node['type'] == 'bool'){

                        // TODO
                        $out .= "{$t}\$item->xxx = {$record}['{$node['source']}'];\n";

                    }

                }
            } else {
                throw new \Exception('primitive parent not allowed');
            }

        }
        return $out;
    }

    protected function emitFinishCode()
    {
        $out  = "// END PARSE\n\n";
        $out .= "// BEGIN SAVE\n";
        $out .= "if(\$items){\n";
        $out .= "  foreach(\$items as \$i){\n";
        $out .= "    if(!\$i->exists())){\n";
        $out .= "      \$i->save();\n";
        $out .= "    }\n";
        $out .= "  }\n";
        $out .= "}\n";
        $out .= "// END SAVE\n";

        return $out;
    }

    protected function parseLogic($node, $parent, $grandp, $d)
    {
        $out = '';

        if(empty($node['logic']) || !is_array($node['logic'])){ return ''; }

        foreach($node['logic'] as $rule){

            // Confirm valid Rule
            if(!$this->isValidRule($rule)){
                throw new \Exception("Invalid logic rule @ depth $d");
            }

            // Determine Scope
            if($rule['scope'] == 'parent'){

                if(!$parent){ throw new \Exception("Invalid logic rule referencing non-existant parent @ deph $d"); }

            } else if($rule['scope'] == 'siblings'){

            } else if($rule['scope'] == 'children'){

            }

        }

        return $out;
    }

    protected function isValidRule($rule)
    {
        if(!array_key_exists('scope', $rule) || !in_array($rule['scope'], ['parent', 'siblings', 'children'])) return false;
        if(!array_key_exists('field', $rule)) return false;
        if(!array_key_exists('operator', $rule)) return false;
        if(!array_key_exists('value', $rule)) return false;

        return true;
    }

    protected function isValidNode($node)
    {
        if(!array_key_exists('type',     $node) || !in_array($node['type'], ['array', 'object', 'number', 'text', 'bool'])) return false;
        if(!array_key_exists('source',   $node)) return false;
        if(!array_key_exists('target',   $node)) return false;
        if(!array_key_exists('config',   $node)) return false;
        if(!array_key_exists('logic',    $node)) return false;
        if(!array_key_exists('children', $node)) return false;

        return true;
    }

    protected function indent($level, $multiplier, $char){
        $str = '';
        for($i = 0; $i < $level*$multiplier; $i++){
            $str .= $char;
        }
        return $str;
    }

}